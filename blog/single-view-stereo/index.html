<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0"><title>Single View Stereo</title><script src=/lib/mathjax.js></script><script id=MathJax-script async src=https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3&#x2F;es5&#x2F;tex-chtml.js></script><link rel=stylesheet href=/style.css><link rel=stylesheet href=https://use.edgefonts.net/c/26d4b4/1w;source-code-pro,2,glz:W:n4,gm5:W:n7;source-sans-pro,2,2cm9PD:W:i2,2cm9PG:W:i3,2cm9PJ:W:i4,2cm9PL:W:i6,2cm9PN:W:i7,2cm9PQ:W:i9,2cm9PC:W:n2,2cm9PF:W:n3,2cm9PH:W:n4,2cm9PK:W:n6,2cm9PM:W:n7,2cm9PP:W:n9;volkhov,2,Wj9:W:i4,WjC:W:i7,WjD:W:n4,WjB:W:n7/l media=all><script>!function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('phc_hMCWtDK8me4vyrMX9X7NnxYpZtv9nAStlew5rIKyjt',{api_host:'https://app.posthog.com'})</script><script>(function(w,d,e,u,f,l,n){w[f]=w[f]||function(){(w[f].q=w[f].q||[])
    .push(arguments);},l=d.createElement(e),l.async=1,l.src=u,
    n=d.getElementsByTagName(e)[0],n.parentNode.insertBefore(l,n);})
    (window,document,'script','https://assets.mailerlite.com/js/universal.js','ml');
    ml('account', '696461');</script><body><script src=/lib/navbar.js></script><nav class=sticky><section class=navigation><a href=javascript:void(0); class=navigation-item onclick=toggleNavButton()><i class="fa fa-bars icon"></i><span class=nav-menu>Menu</span></a> <a class=navigation-item href="/">HOME</a> <a class=navigation-item href="/annual-reports/">ANNUAL REPORTS</a> <a class=navigation-item href="/blog/">BLOG</a> <a class=navigation-item href="/book-summaries/">BOOK SUMMARIES</a> <a class=navigation-item href="/contact/">CONTACT</a></section></nav><section class=content><h1>Single View Stereo</h1><article class=section-content><p>Stereo Vision is traditionally done with the help of two cameras which take images simultaneously. <a href="/">Me</a> and <a href="http://www.shivangagrawal.in/">Shivang Agarwal</a> thought of working on Single View Stereo or Monocular Stereo Vision for <a href="http://swarm-iitkgp.github.io/">Swarm Robotics</a> as the starting point of something called as &quot;Distributed Vision&quot;. More about distributed vision in a future post.</p><h2 id=the-problem>The Problem</h2><p>Traditionally stereo vision (generating disparity maps) is achieved by using two synchronized cameras taking the pictures at the same time and in which we know how far the cameras are (the translational matrix $ T $) and how are the cameras orientated with respect to each other (The rotational matrix $ R $) by doing the camera calibration once at the start. Now the problem is that we don't want to use two cameras but we want to achieve the exact same thing using only one camera and the $ R $ and $ T $ matrix change with every set of images and plus for camera calibration we traditionally use chess board in which we know the real world distances, while right now we don't know that. What we intend to do is to take a frame, then move the camera and take another frame. So now we have two images and technically we can apply stereo vision. The only problem now is that we don't have the $ R $ and $ T $ matrix in this case. So we can't compute the fundamental matrix $ F $. We now need to figure out how to find $ F $, $ R $ and $ T $.</p><h2 id=mathematical-theory>Mathematical Theory</h2><p>Let's the vector <strong>x</strong> represent any point in the left image and the vector <strong>x'</strong> represent any point in the right image. The matrix relation between these is:</p><p>\begin{equation} x^T F x' = 0 \end{equation}</p><p>Let this be equation <em>(1)</em>.</p><p>Also let the matrix <strong>F</strong> be:</p><p>$$ \left( \begin{array}{ccc} a &amp; b &amp; c\ d &amp; e &amp; f\ g &amp; h &amp; i \end{array} \right) $$</p><p>So as of now, the problem boils down to finding a, b, c, d, e, f, g, h, i.</p><h3 id=no-of-distinct-points-required>No of distinct points required</h3><p>As the equation <em>(1)</em> suggests, if we have the coordinate of many points in left image and their corresponding points in the right image, we can easily figure out the value of the matrix <strong>F</strong>. Let's just start off by taking a single point in the left image $ (x_1, y_1) $ and the corresponding point in the right image $ (x_1', y_1') $</p><p>On plugging these values in equation <em>(1)</em>, we get</p><p>$$ \left( \begin{array}{ccc} x_1 &amp; y_1 &amp; 1 \end{array} \right)</p><p>\left( \begin{array}{ccc} a &amp; b &amp; c \ d &amp; e &amp; f \ g &amp; h &amp; i \end{array} \right)</p><p>\left( \begin{array}{c} x_1' \ y_1' \ 1 \end{array} \right) = 0 $$</p><p>After simplifying, we get</p><p>$$ (x_1x_1')a + (y_1y_1')d + (x_1')g + (x_1y_1')b + (y_1y_1')e + (y_1')h + (x_1)c + (y_1)f + i = 0 $$</p><p>where we have 9 unkowns but only one equation. Interestingly if we try for 9 points, we can have 9 such equtions which can be written as</p><p>$$ \left( \begin{array}{ccccccccc} x_1 x_1' &amp; y_1 y_1' &amp; x_1' &amp; x_1 y_1' &amp; y_1 y_1' &amp; y_1' &amp; x_1 &amp; y_1 &amp; 1 \ ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \ x_9 x_9' &amp; y_9 y_9' &amp; x_9' &amp; x_9 y_9' &amp; y_9 y_9' &amp; y_9' &amp; x_9 &amp; y_9 &amp; 1 \ \end{array} \right)</p><p>\left( \begin{array}{c} a \ b \ c \ d \ e \ f \ g \ h \ i \end{array} \right) = 0 $$</p><p>This is equation <em>(2)</em>.</p><p>which is of the form $$ AX = 0 $$. For this system of equations, we should avoid the trivial solution of every variable being zero thus we will only require 8 points.</p><p>Note: We will use SVD to solve this system of equations. While the minimum number required is 8, a higher number of points will have high accuracy.</p><h3 id=getting-the-value-of-fundamental-matrix-f>Getting the value of Fundamental matrix F</h3><p>Thus we can effectively get the solution of this by using just 8 points. On solving, we can easily obtain the values of a, b, c, d, e, f, g, h and i. Please note, it is very essential to make sure that the fundamental matrix is of rank 2 ie. $$ rank(F) = 2 $$.</p><h3 id=getting-the-essential-matrix-e>Getting the Essential Matrix E</h3><p>Fundamental matrix <strong>F</strong> represents the 2D relationship between the point on the left image and the right image while Essential Matrix <strong>E</strong> tries to actually map the relationships in 3D space. In traditional stereo vision, fundamental matrix is obtained from essential matrix using,</p><p>$$ F = K^{-T} E K^{-1} $$</p><p>This is equation <em>(3)</em>.</p><p>where <strong>K</strong> is the camera calibration matrix. Using the equation <em>(3)</em> we can easily reverse engineer to get the value of <strong>E</strong>.</p><p>$$ E = K^T F K $$</p><p>This is equation <em>(4)</em>.</p><p>It is essential to note here that Essential Matrix also rank 1 ie. $ rank(E) = 2 $.</p><h3 id=calculate-projection>Calculate Projection</h3><p>Let $ P_1 $ and $ P_2 $ be the projection vectors from both the images. Now assuming $ P_1 $ to be our reference point, we can get the $ P_2 $ in terms of the Rotational Matrix <strong>R</strong> and <strong>T</strong>.</p><p>$$ P_1 = K \left( \begin{array}{cc} I_{3x3} &amp; 0 \end{array} \right) $$</p><p>This is equation <em>(5)</em>.</p><p>$$ P_2 = K \left( \begin{array}{cc} R &amp; T \end{array} \right) $$</p><p>This is equation <em>(6)</em>.</p><h3 id=relation-between-e-r-and-t>Relation between E, R and T</h3><p>Now that we have got E, we can decompose that into <strong>R</strong> and <strong>T</strong>. The relation between these is:</p><p>$$ E = [ T ]_{\times} R $$</p><p>This is equation <em>(7)</em>.</p><p>Note: Here we take a cross product between the two matrix.</p><h3 id=reconstructing-t>Reconstructing T</h3><p>This can be visualized with the help of Epipolar Geometry. The ray between the two camera locations plus the rays pointing to the point from both the camera locations form a plane. As you sweep a plane across these, all the epilines will converge into a single point a.k.a <strong>epipole</strong> which will be somewhere in between the line joining the two camera locations. With both the epipoles we can now know the vector <strong>T</strong>. Because the epipole is the projection of the camera location on the image plane of the other camera image on the line joining the two locations, we can say that,</p><p>$$ P_2 \left( \begin{array}{c} 0 \ 1 \end{array} \right) = \left( \begin{array}{cc} R &amp; T \end{array} \right) \left( \begin{array}{c} 0 \ 1 \end{array} \right) $$</p><p>This is equation <em>(8)</em>.</p><p>Now we can also say using the priciples in traditional stereo vision,</p><p>$$ T^T E = 0 $$</p><p>This is equation <em>(9)</em>.</p><p>which basically means that left nullspace of the essential matrix is the epipole in right image. Thus we can decompose <strong>E</strong> by using SVD as,</p><p>$$ E = U \left( \begin{array}{ccc} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right) $$</p><p>This is equation <em>(10)</em>.</p><p>where</p><p>$$ U = \left( \begin{array}{ccc} u_1 &amp; u_2 &amp; u_3 \end{array} \right) $$</p><p>and thus we can say that $ T = -u_3 $ or $ T = u_3 $ which are two values.</p><h3 id=reconstructing-r>Reconstructing R</h3><p>Once the value of <strong>T</strong> is successfully extracted from <strong>E</strong> matrix, we can show using some linear algebra that</p><p>$$ R = U \left( \begin{array}{ccc} 0 &amp; -1 &amp; 0 \ 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right) V^T $$</p><p>This is equation <em>(11)</em>.</p><p>or</p><p>$$ R = U \left( \begin{array}{ccc} 0 &amp; 1 &amp; 0 \ -1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right) V^T $$</p><p>This is equation <em>(12)</em>.</p><p>where <strong>U</strong> and <strong>V</strong> are matrix found from SVD of <strong>E</strong> of matrix.</p><h3 id=removing-extraneous-values>Removing Extraneous Values</h3><p>Since we are getting two values of <strong>R</strong> and <strong>T</strong>, we have total of 4 permutations of these while only one is valid. Now, it is actually interesting to note what all of these values represent. The correct value represents the point actually in front of both the images. The other values represent the point at back in either of the images or both of them. So to get this we can get the 3D location of the point (this is called as <strong>Point Triangulation</strong> that we are seeing. If the z-coordinate is positive then we have found our correct solution because all other values should be negative since we have assumed left image to be our reference point.</p><h3 id=point-triangulation>Point Triangulation</h3><p>We can get the point triangulation by,</p><p>$$ \lambda \left( \begin{array}{c} X \ 1 \end{array} \right) = P_1 \left( \begin{array}{c} X \ 1 \end{array} \right) $$</p><p>This is equation <em>(13)</em>.</p><p>This implies that the cross product of two vectors must be zero. Thus,</p><p>$$ \left( \begin{array}{c} X_1 \ 1 \end{array} \right) P_1 \left( \begin{array}{c} X \ 1 \end{array} \right) = 0 $$</p><p>This is equation <em>(14)</em>.</p><p>And,</p><p>$$ \left( \begin{array}{c} X_2 \ 1 \end{array} \right) = P_2 \left( \begin{array}{c} X \ 1 \end{array} \right) = 0 $$</p><p>This is equation <em>(15)</em>.</p><p>Thus we will get the x, y, and z coordinate of all the points. Now we can discard the solutions by checking their z coordinate as described in the above section.</p><p>Note: To get more accurate values, we can take multiple points and use least squares method to get better results.</p><h2 id=actual-implementation>Actual Implementation</h2><h3 id=getting-corresponding-feature-points>Getting corresponding feature points</h3><p>As we said above that we can find the fundamental matrix if we get the corresponding points from both the images, we first need to find all of those points. Technically we need only 8 points to uniquely determine the fundamental matrix but since we are dealing with real world coordinates from camera (which aren't perfect) so we will take as many points as possible. We will use linear least square algorithms which can be solved using SVD, with RANSAC to get more accurate results which will work better with more number of points.</p><p>To get those points, we can use either <strong>SIFT (Scale-invariant Feature Transform</strong> or <strong>ORB (Oriented FAST and rotated BRIEF)</strong> or <strong>DAISY</strong> algorithm to get the feature points. In this SIFT algorithm is generally more accurate but it takes more computational resources and since we are dealing with a real time problem, it will be better to use <strong>ORB</strong> which is fast and reliable and comes with opencv unlike Daisy.</p><h3 id=why-not-cv-stereocalibrate>Why not cv::stereoCalibrate()</h3><p>This function could have been used which does all of our work to calculate the <strong>R</strong>, <strong>T</strong>, <strong>F</strong>, <strong>K</strong> and <strong>E</strong> matrix for us but unfortunately we can't use this as we need the corresponding points in the actual 3D world that we are going to pass which we don't know. In traditional stereo vision using two cameras, this is not a problem since we use a chessboard in which we know the actual world distances between the two points and we just do it once so as to get all the values. For our problem, we need to calibrate the cameras again and again for every frames that we take in and we won't even know the actual 3D coordinate for the same.</p><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#eeffff>Mat cv</span><span style=color:#89ddff>::</span><span style=color:#82aaff>findFundamentalMat</span><span style=color:#89ddff>()
</span></code></pre><p>which takes in two input arrays each of which correspond to their respective points in the left and the right image and gives us Fundamental Matrix <strong>F</strong>. This method uses RANSAC to compute the fundamental matrix and gives it to us after cleaning it up so this is finally of rank 2 as we require.</p><h3 id=decomposing-f-into-e-t-p-1-and-p-2>Decomposing $ F $ into $ E $, $ T $, $ P_1 $ and $ P_2 $</h3><p>This is the most challenging part of this problem. We now have <strong>F</strong> but we don't have <strong>E</strong>, <strong>R</strong>, <strong>T</strong>, $ P_1 $ and $ P_2 $. Unfortunately there is no inbuilt method in opencv to actually implement this for us so we will have to type this out all by ourselves. Since we know the mathematics behind it, we can easily use the OpenCV library for linear algebra and compute this. Again in this since we have many points and not just one we will employ SVD algorithm to help us in solving the various matrix equations which in turn gives us an approximate solution. While doing this we will have to be careful about which format we choosing our data to be because that format has to be compatible with the rest of the OpenCV functions as well because we intend to use the other methods in OpenCV to simply our job afterwards.</p><p><strong>Note:</strong> This gives us 4 values of <strong>R</strong> and <strong>T</strong>. We need to remove these by triangulation of points.</p><h3 id=removing-extra-points-by-triangulation>Removing extra points by triangulation</h3><p>As we mentioned above, we are getting 4 values of <strong>R</strong> and <strong>T</strong> while we only require one. Now we choose a point and try to triangulate it with respect to both the image planes so that we can know whether they lie in front of them or at the back. To do this there exists a function named</p><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#c792ea>void </span><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#82aaff>triangulatePoints</span><span style=color:#89ddff>()
</span></code></pre><p>which reconstructs the point by triangulation. We have mentioned the maths behind it above. It takes Projection Matrix $ P_1 $ and $ P_2 $ and arrays of points corresponding to each image in two separate arrays and outputs the 3D coordinates in a 4D array in which the last one is the homogeneous coordinate. Now we can easily see which points are in the front and thus we can take that particular value of <strong>R</strong> and <strong>T</strong> while we discard the rest.</p><h3 id=image-rectification-parameters>Image Rectification parameters</h3><p>Now we have all the values that we require but still the images have a definite epipole. This means that the images aren't exactly &quot;straight&quot; and thus we will need to straighten this out so that we get epipoles at infinity. The benefit of doing this is that now we will need to search for the corresponding point in the x-coordinate only instead of seaching in the whole area. Luckily, we have an opencv function which can do this for us, namely</p><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#c792ea>void </span><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#82aaff>stereoRectify</span><span style=color:#89ddff>()
</span></code></pre><p>which gives us the new $ R_1 $, $ R_2 $, $ P_1 $ and $ P_2 $ for each of the image. The better part about this function is that this can even get the value of <strong>Q</strong> which gives us the relation between the disparity map and the depth map which we will need further to show the image in 3D.</p><h3 id=rectified-image>Rectified Image</h3><p>Now we have got the rectification parameters. After this we will have to make the corresponding changes in the image according to those parameters. Luckily, we have an opencv function namely</p><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#c792ea>void </span><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#82aaff>undistortPoints</span><span style=color:#89ddff>()
</span></code></pre><p>which maps the initial point coordinates to their final destination coordinates.</p><h3 id=generating-disparity-map-with-blob-matching>Generating disparity map with Blob Matching</h3><p>Now we can finally the use opencv function,</p><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#eeffff>StereoBM</span><span style=color:#89ddff>::</span><span style=color:#82aaff>StereoBM</span><span style=color:#89ddff>()
</span></code></pre><pre style=background-color:#212121>
<code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#c792ea>void </span><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#eeffff>StereoBM::operator</span><span style=color:#89ddff>()
</span></code></pre><p>which operates only on rectified images to generate the disparity map for us.</p><h3 id=getting-the-depth-map>Getting the depth map</h3><p>Since we now have the disparity map and the <strong>Q</strong> matrix we can easily compute the depth map. Luckily there exists an opencv function for the same namely,</p><pre style=background-color:#212121>
<code class=language-cp data-lang=cp><span style=font-style:italic;color:#c792ea>void </span><span style=color:#eeffff>cv</span><span style=color:#89ddff>::</span><span style=color:#82aaff>reprojectImageTo3D</span><span style=color:#89ddff>()
</span></code></pre><p>You can find the source code for all of this on <a href=https://github.com/Swarm-IITKgp/single-view-stereo>github</a>.</p></article><div class=ml-embedded data-form=OIxuLV></div></section><footer><section class=footer-content><i class="fa fa-copyright footer-element"></i><p class=footer-element>Pranit Bauva</p></section></footer><script src=https://use.fontawesome.com/1ceb47dcca.js></script><script>(function(w,d,e,u,f,l,n){w[f]=w[f]||function(){(w[f].q=w[f].q||[])
    .push(arguments);},l=d.createElement(e),l.async=1,l.src=u,
    n=d.getElementsByTagName(e)[0],n.parentNode.insertBefore(l,n);})
    (window,document,'script','https://assets.mailerlite.com/js/universal.js','ml');
    ml('account', '696461');</script>