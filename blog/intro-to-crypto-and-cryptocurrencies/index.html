<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0"><title>Introduction to Crypto and Cryptocurrencies</title><script src=/lib/mathjax.js></script><script id=MathJax-script async src=https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3&#x2F;es5&#x2F;tex-chtml.js></script><link rel=stylesheet href=/style.css><link rel=stylesheet href=https://use.edgefonts.net/c/26d4b4/1w;source-code-pro,2,glz:W:n4,gm5:W:n7;source-sans-pro,2,2cm9PD:W:i2,2cm9PG:W:i3,2cm9PJ:W:i4,2cm9PL:W:i6,2cm9PN:W:i7,2cm9PQ:W:i9,2cm9PC:W:n2,2cm9PF:W:n3,2cm9PH:W:n4,2cm9PK:W:n6,2cm9PM:W:n7,2cm9PP:W:n9;volkhov,2,Wj9:W:i4,WjC:W:i7,WjD:W:n4,WjB:W:n7/l media=all><script>!function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('phc_hMCWtDK8me4vyrMX9X7NnxYpZtv9nAStlew5rIKyjt',{api_host:'https://app.posthog.com'})</script><script>(function(w,d,e,u,f,l,n){w[f]=w[f]||function(){(w[f].q=w[f].q||[])
    .push(arguments);},l=d.createElement(e),l.async=1,l.src=u,
    n=d.getElementsByTagName(e)[0],n.parentNode.insertBefore(l,n);})
    (window,document,'script','https://assets.mailerlite.com/js/universal.js','ml');
    ml('account', '696461');</script><body><script src=/lib/navbar.js></script><nav class=sticky><section class=navigation><a href=javascript:void(0); class=navigation-item onclick=toggleNavButton()><i class="fa fa-bars icon"></i><span class=nav-menu>Menu</span></a> <a class=navigation-item href="/">HOME</a> <a class=navigation-item href="/annual-reports/">ANNUAL REPORTS</a> <a class=navigation-item href="/blog/">BLOG</a> <a class=navigation-item href="/book-summaries/">BOOK SUMMARIES</a> <a class=navigation-item href="/contact/">CONTACT</a></section></nav><section class=content><h1>Introduction to Crypto and Cryptocurrencies</h1><article class=section-content><h2 id=week-1-introduction>Week 1: Introduction</h2><h3 id=cryptographic-hash-functions>Cryptographic Hash Functions</h3><p>A cryptographic function is a mathematical function which can take any string as input, it produces a fixed sized output and it can be computed efficiently.</p><p>Properties required:</p><ul><li>It should be collision-free</li><li>hiding property</li><li>puzzle-free</li></ul><h4 id=hash-property-1-collision-free>Hash Property 1: Collision Free</h4><p>Nobody can find x and y such that $ x!= y $ and $ H(x) = H(y) $. When we say collision free, we don't mean there exists 0 collisions but instead we want it such that nobody can find it.</p><p><strong>Why collisions exists?</strong></p><p>The possible inputs are a very big set while the possible outputs are a quite small set. If we are dealing with 256-bit crypto functions then the input can be anywhere from 1 byte to 1 gigabyte or even more but the output has to be in 256-bits. Thus it gets crowded and there <em>will be collisions</em>, we just have to make sure that it is super difficult to find them.</p><p><strong>How to find a collision?</strong></p><p>Try $ {2^{130}} $ random chosen inputs and 99.8% chance that two of them will collide. So no matter what the hash function is, it any which takes too longer. Just to give a sense of the numbers, if all current computers in the universe were computing this with combined power right from the start of the universe, then the probability of finding a collision would be around 1% . It is more likely probable that the earth will be hit by a meteor rather than finding a collision.</p><p><strong>Is there a faster way to find collisions?</strong></p><p>For some possible hash functions, yes. For others, we don't know of one</p><p>No hash function has been proved collision-free.</p><p><strong>Application: Hash as a message digest</strong></p><p>If we know $ H(x) = H(y) $, it's safe to assume that $ x = y $.</p><p>That means, to recognize a file that we saw before, just remember the its hash.</p><p>This is useful because the hash is small and can be compared more easily.</p><h4 id=hash-property-2-hiding>Hash Property 2: Hiding</h4><p>We want something like this: Given $ H(x) $, it is infeasible to find $ x $.</p><p>This property fails when the inputs can be really less, for eg. a coin toss.</p><p><strong>Hiding Property:</strong></p><p>If r is chosen from a probability distribution that has <strong>high min-entropy</strong>, then given $ H(r | x) $ , it is infeasible to find x.</p><p>High min-entropy means that the distribution is &quot;very spread out&quot;, so that no particular value is chosen with more than negligible probability.</p><p><strong>Application: Commitment</strong></p><p>Want to &quot;seal a value in an envelope&quot;, and &quot;open the envelope&quot; later.</p><p>Commit to a value, reveal it later.</p><p><strong>Commitment API</strong></p><p>$$ (com, key) := commit(msg) $$</p><p>$$ match := verify(com, key, msg) $$</p><p>To seal $ msg $ in envelope:</p><p>$$ (com, key) := commit(msg) --&gt; publish -&gt; com $$</p><p><strong>To open envelope</strong>:</p><p>Publish $ key $, $ msg $</p><p>anyone can use $ verify() $ to check validity</p><p><strong>Security Properties</strong>:</p><p><em>Hiding</em>: Given $ com $, infeasible to find $ msg $.</p><p><em>Binding</em>: Infeasible to find $ msg != msg' $ such that</p><p>$$ verify(commit(msg), msg') == true $$</p><p>$$ commit(msg) := (H(key | msg), key) $$</p><p>where <code>key</code> is a random 256-bit value</p><p>$$ verify(com, key, msg) := (H(key | msg) == com) $$</p><p><strong>Security Properties</strong>:</p><p><em>Hiding</em>: Given $ H(key | msg) $ , infeasible to find $ msg $.</p><p><em>Binding</em>: Infeasible to find $ msg != msg' $ such that</p><p>$ H(key | msg) == H(key | msg') $</p><h4 id=hash-property-3-puzzle-friendly>Hash Property 3: Puzzle-friendly:</h4><p>For every possible output value y, if k is chosen from a distribution with <strong>high min-entropy</strong>, then it is infeasible to find x such that $ H(k | x) = y $.</p><p><strong>Application: Search Puzzle</strong></p><p>Given a &quot;puzzle ID&quot; id (from high min-entropy distribution), and a target set Y:</p><p>Try to find a &quot;solution&quot; x such that $ H(id | x) \in Y $</p><p>Puzzle-friendly property implies that no solving strategy is much better than trying random values of x.</p><h4 id=sha-256-hash-function>SHA-256 hash function</h4><p>Theorem: If c is collision free then the hash function is also collision free.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;1.png alt="" class=image></div><h2 id=hash-pointers-and-data-structures>Hash Pointers and Data Structures</h2><p>Hash Pointer is:</p><ul><li>pointer to where some info is stored</li><li>(cryptographic) hash of the info</li></ul><p>If we have a hash, we can:</p><ul><li>ask to get the info back</li><li>verify that it hasn't changed</li></ul><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;2.png alt="" class=image></div><p>We can take any data structure and build it with the help of a hash pointer.</p><p>Let's take an example of building a linked list. We can build a linked list with the help of a hash pointer like this:</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;3.png alt="" class=image></div><p>In this kind of a data structure one can add things at the end of the list but if somebody wants to modify a previously stored list, then it is not possible. This is because let's say, you change the data of one element, now the hash that is stored in the pointer will mis-match to the one actually stored and thus we can get notified of any tampering. Well we can technically change the hash pointer to which it points but then the hash of that particular element and thus a chain reaction will change and then at the end head of the list would need to be changed which is not possible.</p><p>We can also bring a binary tree with the help of a hash pointer. This is commonly known as &quot;Merkele Tree&quot;.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;4.png alt="" class=image></div><p>It is very easy to even verify the data that we have and the time complexity of the algorithm will be $ \Theta(\log n) $</p><h4 id=advantages-of-merkle-tree>Advantages of Merkle Tree</h4><ul><li>Tree holds many items but just need to remember the root hash</li><li>Can verify membership in $ \Theta(\log n) $ time/space</li></ul><p><strong>Variant</strong>: sorted Merkle Tree</p><ul><li>Can verify non-membership in $ \Theta(\log n) $ time/space</li></ul><p><strong>More generally</strong>, we can use hash pointers in any pointer-based data structure that has no cycles.</p><h3 id=digital-signatures>Digital Signatures</h3><p>We want digital signatures such that only one person can sign but anyone can verify. Signature is tied to a particular document and can't be cut-and-pasted to another doc.</p><h4 id=api-for-digital-signatures>API for Digital Signatures</h4><p>$$ (sk, pk) := generateKeys(keysize) $$</p><p>$$ sig := sign(sk, message) $$</p><p>$$ isValid := verify(pk, message, sig) $$</p><p>where,</p><p>$ sk $: secret signing key</p><p>$ pk $: public verification key</p><h4 id=requirements>Requirements</h4><ul><li>Signatures should be able to be verified: $$ verify(pk, message, sign(sk, message)) == true $$</li><li>Signatures should not be forged. A person who knows you public key should not be able to produce a verifiable signature on another message.</li></ul><h4 id=practical-things-which-need-to-be-taken-care-of>Practical things which need to be taken care of</h4><ul><li>Algorithms are randomized so we need a good source of randomness</li><li>limit on message size. fix: use Hash(message) rather than message</li><li>fun trick: sign a hash pointer, signature &quot;covers&quot; the whole structure</li></ul><h4 id=bitcoin-things>Bitcoin things</h4><p>Bitcoin uses ECDSA standard. ECSDA stands for <em>Elliptic Curve Digital Signature Algorithm</em> which relies on hairy math.</p><p>Good randomness is essential for the proper functioning of ECDSA or one will probably leak your private key.</p><h4 id=public-keys-as-identities>Public Keys as Identities</h4><p>One useful trick out of this is that a public key is considered as equivalent as an identity. If we see a signature that we can verify with a public key then that particular individual is saying that message. If we know the secret key along with the private key, then one can sign messages on behalf of that person.</p><h4 id=how-to-make-a-new-identity>How to make a new identity</h4><p>Create a new, random key-pair (sk, pk) where $ pk $ is the public &quot;name&quot; you can use (usually better to use $ Hash(pk) $). $ sk $ lets you &quot;speak for&quot; the identity</p><p>You can control the identity, because only you know $ sk $ if $ pk $ &quot;looks random&quot;, nobody needs to know who you are</p><p>This brings us to the idea of decentralized identity management</p><h4 id=decentralized-identity-management>Decentralized identity management</h4><p>Anybody can make a new identity at any time and one can make as many as desired! And the best part is there is no central point of cooridination.</p><p>These identities are called &quot;addresses&quot; in Bitcoin.</p><h4 id=privacy>Privacy</h4><p>Addresses not directly connected to real-world identity. But observer can link together an address's activity over time, make inferences.</p><h3 id=a-simple-cryptocurrency>A Simple Cryptocurrency</h3><h4 id=goofy-coin>Goofy Coin</h4><p>Let's take the simple example of Goofy coin.</p><p>Goofy can create new coins. When Goofy creates a coin, it belongs to him. Now that coin will be signed by Goofy by the method <code>CreateCoin[uniqueID]</code>.</p><p>A coin's owner can spend it. Now Goofy has to give it to Alice so it creates a data structure pointing to Alice's public key and Goofy signs it. Now Alice is able to present the whole data structure and prove that Goofy gave it to her. Now Alice can pass it again to Bob.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;5.png alt="" class=image></div><p>Goofy coin is insecure in the way that it doesn't take care of the double spending problem. Now in this Goofy can give the coin to many people and the other person won't ever know whether that coin has been given to someone else or not. This is the main design challenge in digital currency.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;6.png alt="" class=image></div><h4 id=scrooge-coin>Scrooge Coin</h4><p>Scrooge publishes a history of all transactions (a block chain, signed by Scrooge).</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;7.png alt="" class=image></div><p>$ CreateCoins $ transaction creates new coins. This is valid because Scrooge said so. In the transaction type, there is a table of coins created which have the id, value and a recipient address. If Scrooge puts it into history then it is valid and we don't need to worry.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;8.png alt="" class=image></div><p>$ PayCoins $ transaction consumes (and destroys) some coins, and creates new coins of the same total value. This is valid if:</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;9.png alt="" class=image></div><ul><li>consumed coins valid</li><li>not already consumed</li><li>total value out = total value in</li><li>signed by owners of all consumed coins</li></ul><h4 id=immutable-coins>Immutable coins</h4><p>Coins can't be transferred, subdivided into smaller pieces, or combined into a bigger one.</p><p>But: you can get the same effect by using transactions to subdivide: create new trans. You can consume your coin or pay out two new coins to yourself.</p><p>Scrooge coins is still centralized.</p><h2 id=week-2-how-bitcoin-achieves-decentralization>Week 2: How Bitcoin achieves decentralization</h2><h3 id=centralization-vs-decentralization>Centralization vs Decentralization</h3><p>They way bitcoin achieves decentralization is by combination of technical and clever incentive engineering.</p><p>Decentralization is not all-or-nothing. Best example is e-mail which is a decentralized protocol, but dominated by centralized webmail services.</p><h4 id=aspects-of-decentralization>Aspects of decentralization</h4><ol><li>Who maintains the ledger?</li><li>Who has authority over which transactions are valid?</li><li>Who creates new bitcoins?</li><li>Who determines how the rules of the system change?</li><li>How do bitcoins acquire exchange value?</li></ol><p>Beyond the protocol:</p><p>exchanges, wallet software, service providers ...</p><p><strong>Aspects of decentralization in Bitcoin</strong></p><p><em>Peer-to-Peer network</em>:</p><ul><li>open to anyone, low barrier to entry</li></ul><p><em>Mining</em>:</p><ul><li>open to anyone, but inevitable concentration of power</li><li>often seen as undesirable</li></ul><p><em>Updates to software</em>:</p><ul><li>core developers trusted by community, have great power</li></ul><h3 id=distributed-consensus>Distributed Consensus</h3><p><strong>Bitcoin's key challenge</strong>:</p><p>Key technical challenge of decentralized e-cash: distributed consensus, or how to decentralize ScroogeCoin.</p><p><strong>Why consensus protocols?</strong></p><p>Traditional motivation: reliability in distributed system</p><p><em>Distributed key-value store</em> enables various applications like DNS, public key directory, stock trades, ... which are all good for altcoins.</p><p><em>Altcoins</em>: They are systems built on bitcoins like principles to achieve slightly different role, sometimes currency systems sometimes not currency systems.</p><p><strong>Defining distributed consensus</strong></p><ul><li>The protocol terminates and all correct nodes decide on the same value</li><li>This value must have been proposed by some correct node</li></ul><p><strong>How distributed consensus works in bitcoin</strong></p><p>When Alice wants to pay Bob: she broadcasts the transaction to all Bitcoin nodes. The transaction has Alice's signature which other nodes need in order to know that it came from Alice, it will also contain Bob's public key which is his address at where he wants to receive the bitcoin and further it contains a hash. This hash is a way for Alice to link together this transaction or this coin to her receipt of this coin from someone else.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;10.png alt="" class=image></div><p>Note: In this, Bob is not in this picture. If Bob wants to be notified that this transaction has in fact happened then he might want to run a peer-to-peer node on the network in order to listen and be sure that he has received the bitcoins but it is not required since the bitcoins will be his whether he is notified or not.</p><p><strong>What do the nodes want to reach a consensus on?</strong></p><p>Given that a variety of users are broadcasting these transactions to the network, what everybody wants to reach consensus on is exactly which transactions were broadcast and the order in which they happened.</p><p><strong>How consensus could work in Bitcoin?</strong></p><p>At any given time:</p><ul><li>All nodes have a sequence of <em>blocks of transactions</em> they have reached consensus on</li><li>Each node has a set of outstanding transactions it's heard about</li></ul><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;11.png alt="" class=image></div><p>Although this has things similar to bitcoins, this is not how bitcoins exactly work. This is because, doing things in this way is a really hard technical problem for a variety of reason.</p><p><strong>Why consensus is hard?</strong></p><ul><li>Nodes may crash</li><li>Nodes may be malicious</li><li>Network is imperfect<ul><li>Not all pairs of nodes connected</li><li>Faults in network</li><li>Latency</li></ul></li></ul><p>One particular consequence of high latency is that there is no notion of global time. Not all nodes can agree with a particular order of events just on basis of timestamps.</p><p><strong>Many impossibility result:</strong></p><ol><li>Byzantine generals problem</li><li>Fischer-Lynch-Paterson (deterministic nodes): consensus impossible with a single faulty node</li></ol><p>Despite of these, there are still some well known protocols like <strong>Paxos</strong> which can never give inconsistant result but can (rarely) get stuck.</p><p><strong>Understanding impossibility results</strong></p><ul><li>These results say more about the model than about the problem</li><li>The models were developed to study systems like distributed databases.</li></ul><p>Bitcoin consensus works better in practice than in theory. Theory is still catching up. <strong>BUT</strong> theory is important as it can help predict unforeseen attacks.</p><p><strong>Some things Bitcoin does differently</strong>:</p><ul><li><em>Introduces incentives</em>: Possible only because it's a currency!</li><li><em>Embraces randomness</em>:<ul><li>Does away with the notion of a specific end-point</li><li>Consensus happens over long time scales - about 1 hour</li><li>Gives a probabilistic model about the verification of transaction over time with exponential growth.</li></ul></li></ul><h3 id=consensus-without-identity-the-block-chain>Consensus without identity: The Block Chain</h3><p><strong>Why identity?</strong></p><p><em>Pragmatic</em>: some protocols need node IDs</p><p><em>Security</em>: assume less than 50% malicious</p><p><strong>Why don't Bitcoins nodes have identities?</strong></p><ul><li>Identity is hard in a P2P sytem - <em>Sybil attack</em></li><li>Pseudonymity is a goal of Bitcoin</li></ul><h4 id=key-idea-implicit-consensus>Key Idea: Implicit Consensus</h4><p>In each round, random node is picked. This node proposes the next block in the chain.</p><p>Other nodes implicitly accept/reject this block:</p><ul><li>by either extending it</li><li>or ignoring it and extending chain from earlier block</li></ul><p><strong>Every block contains hash of the block it extends</strong>.</p><h4 id=consensus-algorithm-simplified>Consensus Algorithm (simplified)</h4><ol><li>New transactions are broadcast to all nodes</li><li>Each node collects new transactions into a block</li><li>In each round a <em>random</em> node gets to broadcast its block</li><li>Other nodes accept the block only if all transactions in it are valid (unspent, valid signatures)</li><li>Nodes express their acceptance of the block by including its hash in the next block they create</li></ol><h4 id=what-can-a-malicious-node-do>What can a malicious node do?</h4><p><strong>What can't an attacker not do?</strong></p><ul><li>It can't forge a signature thus it can't spend the Bitcoin on behalf of the original owner</li><li>While it can purposely choose to ignore verifying a transaction which can cause delays but then that transaction will be taken up by some other node and thus it can be signed.</li></ul><p><strong>Double Spending Attack:</strong></p><p>When Alice pays Bob a Bitcoin, that means she will create a transaction from her address to Bob's public address. She broadcasts it to the network and let's say some honest node creates this block, listens to the transaction and includes it in that block.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;12.png alt="" class=image></div><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;13.png alt="" class=image></div><p>Summarizing:</p><ul><li>Protection against invalid transactions is cryptographic, but enforced by consensus</li><li>Protection against double-spending is purely by consensus</li><li>You're never 100% sure a transaction is in consensus branch. Guarantee is probabilistic</li></ul><h3 id=incentives-and-proof-of-work>Incentives and Proof of Work</h3><p><strong>Assumption of honesty is problematic</strong>.</p><p>Can we give nodes <em>incentives</em> for behaving honestly?</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;14.png alt="" class=image></div><h4 id=incentive-1-block-reward>Incentive 1: block reward</h4><p>Creator of block gets to</p><ul><li>include <em>special coin-created transaction</em> in the block</li><li>choose recipient address of this transaction</li></ul><p>Value is fixed: current 25 BTC, halves every 4 years</p><p>Block creator gets to &quot;collect&quot; the reward only if the block ends up on long-term consensus branch!</p><p><strong>There's a finite supply of Bitcoins</strong></p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;15.png alt="" class=image></div><h4 id=incentive-2-transaction-fees>Incentive 2: transaction fees</h4><ul><li>Creator of transaction can choose to make output value less than input value</li><li>Remainder is a transaction fee and goes to the block creator</li><li>Purely voluntary, like a tip</li></ul><p><strong>Remaining Problems</strong></p><ol><li>How to pick a random node?</li><li>How to avoid a free-for-all due to rewards?</li><li>How to prevent Sybil attacks?</li></ol><p>The solution to the problems is <strong>Proof of Work</strong>.</p><h4 id=proof-of-work>Proof of Work</h4><p>To approximate selecting a random node: select nodes in proportion to a resource that no one can monopolize (we hope)</p><ul><li>In proportion to computing power: proof-of-work</li><li>In proportion to ownership: proof-of-stake</li></ul><h4 id=equivalent-views-of-proof-of-work>Equivalent views of proof of work</h4><ol><li>Select nodes in proportion to computing power</li><li>Let nodes compete for right to create block</li><li>Make it moderately hard to create new identities</li></ol><h4 id=proof-of-work-in-bitcoin>Proof of work in Bitcoin</h4><p><strong>Hash Puzzles</strong></p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;16.png alt="" class=image></div><h5 id=pow-property-1-difficult-to-compute>PoW property 1: difficult to compute</h5><p>It takes around $ 10^{ 20 } $ hashes/block</p><h5 id=pow-property-2-parameterizable-cost>PoW property 2: parameterizable cost</h5><p>Nodes automatically re-calculate the target every two weeks</p><p>Goal: <em>average</em> time between blocks = 10 mins</p><p>This means that the next time one tries to hash a block is not just dependent on it's own computing power but it mainly depends on the computing power of other people. To tell it more subtly:</p><p><code>Prob(Alice wins next block) = fraction of global hash power she controls</code></p><p><strong>Key security assumption</strong>:</p><p>Attacks infeasible if majority of miners <em>weighted by hash power</em> follow the protocol.</p><p><strong>Solving hash puzzles is probabilistic</strong>:</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;17.png alt="" class=image></div><h5 id=pow-property-3-trivial-to-verify>PoW property 3: trivial to verify</h5><p>Nonce must be published as part of block.</p><p>Other miners simply verify that $$ H(nonce || prevhash || tx || ... || tx) &lt; target $$</p><h3 id=putting-it-all-together>Putting It All Together</h3><h4 id=mining-economics>Mining Economics</h4><p>$$ Profit = reward - hardware - electricity $$</p><p><strong>Complications</strong>:</p><ul><li>fixed vs. variable costs</li><li>reward depends on global hash rate</li></ul><p><strong>Summary</strong>:</p><ul><li>Identities</li><li>Transactions</li><li>P2P network</li><li>Block chain &amp; consensus</li><li>Hash Puzzles &amp; Mining</li></ul><h4 id=bitcoin-is-bootstrapped>Bitcoin is bootstrapped</h4><p>There is a circle of dependency between <code>security of block chain</code>, <code>health of mining ecosystem</code>, and <code>value of currency</code>.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;18.png alt="" class=image></div><p>It is a very tricky process as to how all of these three things were acquired by the Bitcoin system in an interdependent manner. It was of course fueled by media.</p><h4 id=what-can-a-51-attacker-can-do>What can a &quot;51% attacker&quot; can do?</h4><p>Steal coins from existing address? NO</p><p>Suppress some transactions?</p><ul><li>From the block chain, yes</li><li>From the P2P network, no</li></ul><p>Change the block reward? No</p><p>Destroy confidence in Bitcoin? YES</p><h3 id=week-3>Week 3</h3><h4 id=bitcoin-transactions>Bitcoin Transactions</h4><h5 id=an-account-based-ledger-not-bitcoin>An account-based Ledger (not Bitcoin)</h5><p>If we use an account based ledger wherein we store all the trades that can happen then we have something like this:</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;19.png alt="" class=image></div><p>Although the problem with this is that to verify that when the person who promises to pay is a big pain because for that we would have to traverse the whole history of all transactions. In this system there is no way of storing the amount of money a person owns and thus calculating the whole list every time a transaction is made is just too much computationally intensive. If we try to maintain an account of each person, then it would be a sophisticated data structure which would be different from the original block chain.</p><h4 id=a-transaction-based-ledger>A transaction-based Ledger</h4><p>Bitcoin uses something like this.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;20.png alt="" class=image></div><p>The first transaction depicts the creation of a new currency. In the second transaction, the coins are split into two, Bob is given 17 coins while Alice is given 8 coins by herself where, $$ 17 + 8 = 25 $$. So this is called as <em>change address</em> because the address of the transactions owned by Alice have changed. The point is that the transaction totally consumes the full money of the previous block. Thus it is easy to maintain the transactions as well as the amount of money owned by each person.</p><h5 id=a-real-deal-a-bitcoin-transaction>A real deal: A Bitcoin Transaction</h5><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;21.png alt="" class=image></div><p>Three parts:</p><ul><li>Metadata</li><li>Inputs</li><li>Outputs</li></ul><p><strong>Metadata</strong>: Some housekeeping information like size of the transactions, number of inputs and the number of outputs. There is the hash of the entire transaction, and there is a lock-time parameter.</p><p><strong>Input</strong>: It is an array that have inputs of the same form. The inputs specify a previous transaction specifically so they have the hash or hash pointer to it and the index of which transaction which you are actually claiming and after that there is a signature.</p><p><strong>Outputs</strong>: They have a value of a coin and then there is a recipient address.</p><h4 id=bitcoin-scripts>Bitcoin Scripts</h4><p>Each transaction output doesn't just specify a simple public key, but instead it specifies a script.</p><h5 id=an-example>An Example</h5><p>Output &quot;addresses&quot; are really scripts. The most common script in bitcoin is to redeem a previous transaction by signing with the correct public key. This is what an output address would look like in a script:</p><pre style=background-color:#212121>
<code><span style=color:#eeffff>OP_DUP
OP_HASH160
69e02e18...
OP_EQUALVERIFY OP_CHECKSIG
</span></code></pre><p>Input &quot;address&quot; is also a script. So that's a bit of a script that you combine with the output script by concatenation and that gets you a script that you have to run successfully to claim a bitcoin.</p><p><strong>To Verify</strong>: Concatenated script must execute completely with no errors.</p><h5 id=bitcoin-scripting-language>Bitcoin Scripting Language</h5><p>Design goals:</p><ul><li>Built for Bitcoin (inspired by Forth)</li><li>Simple, compact</li><li>Support for cryptography</li><li>Stack-based</li><li>Limits on time/memory</li><li>No looping</li></ul><p>This is not a turing complete language. No looping is there to protect the miner from infinite looping submitted by malicious nodes.</p><h5 id=bitcoin-script-execution-example>Bitcoin Script Execution Example</h5><p>A stack based data structure is the most suitable when you have to perform operations on data. Bitcoin scripting also uses the same. When it sees a data value, it pushes it on top of the stack. When it sees an operation, then it pops the top value of the stack performs the operation and then pushes the output on the top of the stack back.</p><p>Let's say you want to execute this script:</p><pre style=background-color:#212121>
<code><span style=color:#eeffff>&lt;sig&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash?&gt; OP_EQUALVERIFY OP_CHECKSIG
</span></code></pre><p>So the execution will start with pushing <code>&lt;sig&gt;</code> into the stack and then <code>&lt;pubKey&gt;</code>.</p><table><thead><tr><th>Stack<tbody><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;sig&gt;</code></table><p>After that, the operation is <code>OP_DUP</code> which is to duplicate the top of the stack. So after this operation the stack looks like,</p><table><thead><tr><th>Stack<tbody><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;sig&gt;</code></table><p>Then the operation is <code>OP_HASH160</code> which means to hash the top value of the stack. The stack therefore is,</p><table><thead><tr><th>Stack<tbody><tr><td><code>&lt;pubKeyHash&gt;</code><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;sig&gt;</code></table><p>Then the data value <code>&lt;pubKeyHash?&gt;</code>,</p><table><thead><tr><th>Stack<tbody><tr><td><code>&lt;pubKeyHash?&gt;</code><tr><td><code>&lt;pubKeyHash&gt;</code><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;sig&gt;</code></table><p>Then the operation <code>OP_EQUALVERIFY</code> which pops the two topmost elements and then verifies whether the both are equal, if equal then it removes both the values from the stack, otherwise it terminates the execution of the script with a negative response for verification.</p><table><thead><tr><th>Stack<tbody><tr><td><code>&lt;pubKey&gt;</code><tr><td><code>&lt;sig&gt;</code></table><p>Now <code>OP_CHECKSIG</code> checks whether the signature is valid. It can verify signatures without calling special libraries. The input to the signature function is the <strong>entire transaction</strong>. After this the remaining things will be popped out and nothing is left. If we didn't have any errors, then the output is a &quot;yes&quot; which means the transaction is valid.</p><h5 id=bitcoin-script-instructions>Bitcoin Script Instructions</h5><p>256 opcodes total (15 disabled, 75 reserved)</p><ul><li>Arithmetic</li><li>If/then</li><li>Logic/data handling</li><li>Crypto!<ul><li>Hashes</li><li>Signature Verification</li><li>Multi-Signature verification</li></ul></li></ul><p><code>OP_CHECKMULTISIG</code>:</p><ul><li>Built-in support for joint signatures</li><li>Specify <em>n</em> public keys</li><li>Specify <em>t</em></li><li>Verification requires <em>t</em> signatures</li></ul><h5 id=bitcoin-scripts-in-practice-as-of-2014>Bitcoin scripts in practice (as of 2014)</h5><ul><li>Most nodes whitelist known scripts</li><li>99.9% are simple signature checks</li><li>~0.01% are MULTSIG</li><li>~0.01% are Pay-to-Script-Hash</li><li>Remainders are errors, proof-of-burn</li></ul><h5 id=proof-of-burn>Proof-of-Burn</h5><p>It is a script that can never be redeemed. It is provable that those coins have been destroyed and they can't be spent again. One can use <code>OP_RETURN</code> with any arbitrary data and no matter what values you put in before, they get permanently stored in the chain.</p><h5 id=should-sender-specify-scripts>Should Sender specify scripts?</h5><p>Ideally all senders have to send scripts, but this creates a lot of confusion for the user. So a simple hack is to use the hash of a redemption script. The sender doesn't need to specify the entire script but the sender can specify the hash of the script needed to be redeem those coins.</p><h4 id=application-of-bitcoin-scripts>Application of Bitcoin Scripts</h4><h5 id=escrow-transactions>Escrow Transactions</h5><p><strong>Problem</strong></p><p>Let's say Alice sells a big order for apples to Bob. Now Alice doesn't want to pay until Bob delivers the apples and Bob doesn't want to deliver the apples until Alice pays for it.</p><p><strong>Solution</strong></p><p>To solve this problem, we introduce a third party. Alice can create a <code>MULTISIG</code> transaction that requires two or three people to sign to redeem the transaction. So now Alice pays 2-of-3 of Alice, Bob and Judy (MULTISIG) and in this point the coins are held in the escrow and the two can specify where the coins should go. Bob will be satisfied that he is safe sending the goods to Alice, thus he will deliver the apples. Then Alice wants to pay Bob for his services, so to release the money from the escrow and pay to Bob, they both can sign a transaction releasing redeeming the coins from escrow and sending them to Bob and the great thing is that Judy had to never get involved. This requires one extra transaction on the block chain.</p><p>What if Bob didn't send or sent faulty goods? Now Alice doesn't want to pay Bob. In this case, Bob won't sign the transaction because he wants to defy the claim. So in this case Judy involves and helps in settling the dispute. Judy can sign the transaction in whichever direction she wants and thus after obtaining 2 signatures, the coins can be transferred easily.</p><h5 id=green-addresses>Green Addresses</h5><p><strong>Problem</strong></p><p>Alice wants to pay Bob. Bob can't wait 6 verifications to guard against double spends, or is offline completely. So Bob can't go to the block chain and verify the transaction.</p><p><strong>Solution</strong></p><p>To solve this, we need to introduce one bank. Alice pays the bank with the coins. Now this bank has the trust of the people that it never double spends and in return it takes a small part of the transaction. Now when Bob comes online, it can immediately ask the bank to pay him the coins. This idea puts too much trust on the bank and they have historically failed.</p><h5 id=efficient-micro-payments>Efficient micro-payments</h5><p><strong>Problem</strong></p><p>Alice wants to pay Bob for each minute of phone service. She doesn't want to incur a transaction fee every minute. Since the fees are quite low, the transaction costs would seem quite high in comparison.</p><p><strong>Solution</strong></p><p>We can club together many small payments into one payment. We start with a <code>MULTISIG</code> transaction with an amount which is the highest Alice is going to pay which will be signed by Alice and Bob. The first payment is then done by Alice to Bob while returning the rest remaining coins to herself. After next service Alice signs another transaction in which she signs coins for both of the services while paying rest to her. Alice will keep sending these transaction to Bob as long as she is using the service. These aren't getting published in the block chain but is there with Bob. When Alice stop using the service, Bob will take the last transaction (which has the highest coins). So technically all of those transactions are double-spend.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;22.png alt="" class=image></div><p>What is Bob never signs the last transaction?</p><p>Now the coins won't move but Alice will be out of coins she initially deposited. To avoid this, we use <em>lock time</em>. Alice can put up a transaction saying &quot;Pay 100 to Alice, LOCK until time <em>t</em>&quot; which is to be signed by Alice and Bob. The metadata parameter <code>lock_time</code> is used to specify this, and if contains a non-zero value then the transaction can't be published until some time specified by that value in future.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;23.png alt="" class=image></div><h5 id=more-advanced-scripts>More Advanced Scripts</h5><ul><li>Multiplayer Lotteries</li><li>Hash pre-image challenges</li><li>Coin Swapping protocols</li></ul><p>The name for these kind of things is called &quot;smart contracts&quot;.</p><h4 id=bitcoin-blocks>Bitcoin Blocks</h4><p>Why bundle transactions together?</p><ul><li>Single unit of work for miners</li><li>Limit length of hash-chain of blocks<ul><li>Faster to verify history</li></ul></li></ul><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;24.png alt="" class=image></div><h5 id=the-real-deal>The real deal</h5><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;25.png alt="" class=image></div><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;26.png alt="" class=image></div><h4 id=the-bitcoin-network>The Bitcoin Network</h4><h5 id=the-bitcoin-p2p-network>The Bitcoin P2P Network</h5><ul><li>Ad-hoc protocol (runs on TCP port 83330)</li><li>Ad-hoc network with random topology</li><li>All nodes are equal</li><li>New nodes can join at any time</li><li>Forget non-responding nodes after 3 hr</li></ul><h5 id=joining-the-bitcoin-p2p-network>Joining the Bitcoin P2P network</h5><p>When you launch a new node and try to connect to a network, you start with a simple message to one node that you know about. This node is usually called as <em>seed node</em>. Once you find your seed node, you send a special message <code>getaddr()</code> asking to know which all nodes in that node connected to and then you can perform his task iteratively and finally choose the nodes you want to pair up with.</p><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;27.png alt="" class=image></div><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;28.png alt="" class=image></div><h5 id=transaction-propogation-flooding>Transaction Propogation (flooding)</h5><p>This is also called as the gossip protocol. If one node gets to hear about a new transaction from a wallet or an exchange, then that node tries to tell as many people as it can to whom it is connected to and thus this message spreads on the entire network just like people gossiping in the real world.</p><h5 id=should-i-relay-a-proposed-transaction>Should I relay a proposed transaction?</h5><ul><li>Transaction valid with current block chain</li><li>(default) script matches a whitelist<ul><li>avoid unusual scripts</li></ul></li><li>Haven't seen before<ul><li>avoid infinite loops</li></ul></li><li>Doesn't conflict with others I've relayed<ul><li>avoid double-spends</li></ul></li></ul><p>Well behaving nodes implement this, while some nodes might forward transactions without validating as well.</p><h5 id=race-conditions>Race Conditions</h5><p>Transactions or blocks may conflict</p><ul><li>Default behaviour: accept what you hear first</li><li>Network position matters</li><li>Miners may implement other logic!</li></ul><h5 id=block-propogation>Block Propogation</h5><p>Relay a new block when you hear it if:</p><ul><li>Block meets the hash target</li><li>Block has all valid transactions<ul><li>Runs all scripts, even if you wouldn't relay</li></ul></li><li>Block builds on current longest chain<ul><li>Avoid forks</li></ul></li></ul><h5 id=block-propagation-times>Block Propagation Times</h5><div class=image-container><img src=&#x2F;images&#x2F;blog&#x2F;cryptocurrency&#x2F;29.png alt="" class=image></div><h5 id=how-big-is-the-network>How big is the network?</h5><ul><li>Impossible to measure exactly</li><li>Estimates-up to 1M IP addresses/month</li><li>Only about 5k-10k &quot;full nodes&quot;<ul><li>Permanently connected</li><li>Fully-validate</li></ul></li><li>This number may be dropping!</li></ul><h5 id=fully-validating-nodes>Fully-Validating Nodes</h5><ul><li>Permanently connected</li><li>Store entire block chain</li><li>Hear and forward every node/transaction</li></ul><h5 id=tracking-the-utxo-set>Tracking the UTXO set</h5><ul><li>Unspent Transaction Output<ul><li>Everything else can be stored on disk</li></ul></li><li>Currently ~12 M UTXOs<ul><li>Out of 44M transactions</li></ul></li><li>Can easily fit into RAM</li></ul><h5 id=thin-svp-clients-not-fully-validating>Thin/SVP clients (not fully-validating)</h5><p>Idea: don't store everything</p><ul><li>Store block headers only</li><li>Request transactions as needed<ul><li>To verify incoming payment</li></ul></li><li>Trust fully-validating nodes</li></ul><p>1000x cost savings! (20Gb - 23Mb)</p><h4 id=limitations-improvements>Limitations &amp; Improvements</h4><h5 id=hard-coded-limits-in-bitcoin>Hard-Coded limits in Bitcoin</h5><ul><li>10 min average creation time per block</li><li>1 M bytes in a block</li><li>20,000 signature operations per block</li><li>100 M satoshis per bitcoin</li><li>21 M total bitcoins maximum</li><li>50, 25, 12.5 ... bitcoin mining reward</li></ul><h5 id=thoroughput-limits-in-bitcoin>Thoroughput limits in Bitcoin</h5><ul><li>1 bytes/block (10 min)</li><li>more than 250 bytes/transaction</li><li>7 transactions/sec</li></ul><p>Compare to:</p><ul><li>VISA: 2,000 - 10,000 transactions/sec</li><li>PayPal: 50-100 transaction/sec</li></ul><h5 id=cryptographic-limits-in-bitcoin>Cryptographic Limits in Bitcoin</h5><ul><li>Only 1 signature algorithm (ECDSA/P256)</li><li>Hard-coded hash functions</li></ul><p>Crypto primitives might break by 2040 ...</p></article><div class=ml-embedded data-form=OIxuLV></div></section><footer><section class=footer-content><i class="fa fa-copyright footer-element"></i><p class=footer-element>Pranit Bauva</p></section></footer><script src=https://use.fontawesome.com/1ceb47dcca.js></script><script>(function(w,d,e,u,f,l,n){w[f]=w[f]||function(){(w[f].q=w[f].q||[])
    .push(arguments);},l=d.createElement(e),l.async=1,l.src=u,
    n=d.getElementsByTagName(e)[0],n.parentNode.insertBefore(l,n);})
    (window,document,'script','https://assets.mailerlite.com/js/universal.js','ml');
    ml('account', '696461');</script>